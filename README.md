# tosa_for_spirv_codegen

## Introduction

The tosa_for_spirv_codegen project provides a lightweight set of online tools and API's for a user
to easily generate valid SPIR-V™ binary from TOSA based data structures, without using MLIR or other
compiler frameworks.

**[TOSA Specification](https://github.com/arm/tosa-specification)**

**[SPIR-V Specification](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html)**


## How to get started

By default tosa_for_spirv_codegen will build for the native platform. It also supports
building with the Android™ NDK. It assumes that CMake™ with a minimum
version of 3.17.2 is available in the path.

In order to build the tosa_for_spirv_codegen project a number of dependencies are required,
as listed below in the [dependencies](#dependencies) section.

To download these dependencies a script is provided in the root directory that will need to be ran.

``` bash
./download_dependencies.sh
```

#### Native Build

Build needed dependencies:
``` bash
./build_dependencies.sh -t Release
```

Create build folder:
``` bash
mkdir -p build
cd build
cmake ..
```
or if you need position independent code
``` bash
cmake -DCMAKE_POSITION_INDEPENDENT_CODE=ON ..
```

Lastly, compile using `make`:
``` bash
make
```

#### Android Build

The dependencies download script does not include the Android NDK. When building for Android
it is expected that the following environment variables are set:

- NDK_VERSION=[NDK version]
- DEFAULT_NDK=android-ndk-${NDK_VERSION}
- NDK_DIR=[path to the NDK]
- ANDROID_API=[API Version]

Optional (default is arm64-v8a if unset)
- ANDROID_ABI=arm64-v8a

``` bash
./build_dependencies.sh -t Release -a
```

Build command
``` bash
cmake -S .. -B ./android \
      -DCMAKE_TOOLCHAIN_FILE="${NDK_DIR}/build/cmake/android.toolchain.cmake" \
      -DANDROID_ABI="${ANDROID_ABI}"
      -DANDROID_PLATFORM="android-${ANDROID_API}"
```

#### Result
The resulting executable will be located in your build folder under:
`tools/generator/tfsc-generator`. This executable is built by default,
but can be disabled with `-DBUILD_TOSA_2_SPIRV_GENERATOR=OFF`.
More information on the usage can be found in the next section
([tosa_for_spirv_codegen Generator Usage](#generator-usage)).

A static library will also be generated by default in your build folder as follows:
`libtosa_for_spirv_codegen.a`.
To make this a shared library (.so) add the following option
`-DBUILD_SHARED_LIBS=YES`.

By default, the build will also produce the TosaRegen library, `<build folder>/tools/tosaregen/libtosaregen.a`.
The library provides API calls allowing users to recreate TOSA Serialization Library structures from
a tosa_for_spirv_codegen `Module` instance, as well as generating C++ code usable for automatic unit test generation.

Along with the `tosaregen` library, a utility executable `<build folder>/tools/tosaregen/tosaregen` is also built.
The tool allows users to convert SPIR-V disassembly files into C++ TOSA Operator definitions and to generate
operator tests for the `tosa_for_spirv_codegen` library.

More information about the `tosaregen` module can be found in section [TosaRegen usage](#tosaregen-usage).
The compilation can be disabled with `-DBUILD_TOSA_REGEN=OFF`.

CMake only needs to be re-run if the build environment changes (E.g., new dependencies or source
files). Code changes that do not affect these build rules can be
rebuilt simply using `make`.

#### Outputs
- [libtosa_for_spirv_codegen.a / .so](#graph-api-usage) — See **[Graph API Usage](#graph-api-usage)**
- [tools/tosaregen/libtosaregen.a](#tosaregen-usage) — See **[TosaRegen Usage](#tosaregen-usage)**
- [tools/parsers/libtosaSerializationParser.a](#tosaserializationparser-api-usage) — See **[TosaSerializationParser API Usage](#tosaserializationparser-api-usage)**

## Generator Usage

The *tosa_for_spirv_codegen* Generator is a command line executable that makes use of the
[VgfWriter](tools/vgfwriter/include/VgfWriter.hpp) library ('tools/vgfwriter/include/VgfWriter.hpp')
which is a wrapper of the [ML SDK VGF Library](https://arm.github.io/ai-ml-sdk-for-vulkan/vgf-lib/docs/in/index.html).

The VgfWriter library (libvgfWriter.a) is currently enabled by default, but can be disabled by adding
`-DBUILD_VGF_WRITER=OFF` to the CMake command.

The executable can be used to generate SPIR-V in two ways.

### Using a TOSA FlatBuffers File

By using a TOSA FlatBuffers File containing the serialized subgraph you can output a .vgf file
*Example:*
``` bash
./<build folder>/tools/generator/tfsc-generator \
  --tosa-file=examples/simple_maxpool2d.tosa \
  --output-file=output_file.vgf
```

### Using a JSON-formatted FlatBuffers Descriptor

By using a JSON-formatted FlatBuffers descriptor which describes the subgraph you can output a .vgf file.

The FlatBuffers schema file from the TOSA Serialization library must also be
specified using `--schema-file=external/serialization_lib/schema/tosa.fbs`

*Example:*
``` bash
./<build folder>/tools/generator/tfsc-generator \
  --json-file=examples/simple_maxpool2d.json \
  --schema-file=external/serialization_lib/schema/tosa.fbs \
  --output-file=output_file.vgf
```

On a successful execution, the output SPIR-V will be written in binary
format into the output file specified with the `--output-file` option.

This output can be converted into human-readable SPIR-V using the vgf_dump executable in combination
with the SPIR-V Tools disassembler.
``` bash
./external/vgf_encoder/build/vgf_dump/vgf_dump -i output_file.vgf --dump-spirv 0 -o output_file.spv
./external/SPIRV-Tools/build/tools/spirv-dis output_file.spv > disassembledSpv.txt
```

## Examples

Located in `examples` are two files (.tosa and .json) which can be used for testing the tosa_for_spirv_codegen generator.
They consist of a simple model with a single MaxPool2d layer.

## TosaSerializationParser API Usage

As an alternative to the tosa_for_spirv_codegen generator executable described above,
the [TosaSerializationParser.hpp](tools/parsers/include/TosaSerializationParser.hpp)
('tools/parsers/include/TosaSerializationParser.hpp')
is provided, which can be used to generate SPIR-V from a TosaSerialization
data structure easily within C++ code.

*Example:*
``` c++
// Construct TosaSerializationParser object using TosaSerializationBlock or TosaSerializationHandler
TosaSerializationParser parser(&block);

// Call GenerateSPIRV, which returns a SPIR-V binary vector.
// This can then be disassembled into human-readable SPIR-V or passed for execution.
auto binarySpirv = parser.GenerateSPIRV();

// Constants can be retrieved with the function:
// Note: Constants of a 1D tensor, with less than 17 elements, will be stored in the SPIRV binary
//       and will not be in the returned vector
std::vector<ConstantData>& constants parser.GetExternalConstants();
```

This example can be found in the `Readme` unit test located here:
[ParserTests.cpp](tools/parsers/test/ParserTests.cpp) ('tools/parsers/test/ParserTests.cpp').

The parser is currently enabled by default, but can be disabled by adding
`-DBUILD_TOSA_SERIALIZATION_PARSER=OFF` to the CMake command.

### Unit Tests

Unit test are built by default for the TosaSerializationParser.

They can be run using the following command:
``` bash
# To run all tests, including parser tests
./tosa_for_spirv_tests

# To run specifically parser tests
./tosa_for_spirv_tests --gtest_filter=TOSA_FOR_SPIRV_CODEGEN_PARSER*
```

## Graph API Usage

As another alternative a user can manually build a SPIR-V graph using
the graph API and subsequently write SPIR-V.

*Example:*
``` c++

// Create a module and add a graph.
auto module = CreateModule(m_Version);
auto graph{module, graphName};

// Create an input to the graph, this will be the input to the maxpool2d operator
// DescriptorSet will be 0. Binding can be specified or left to default
auto input = graph.AddInput(Tensor{DataType::int8_t, {1,1}}, 0);

// Maxpool attributes
auto kernel = Attribute{{1, 1}, DataType::int8_t};
auto stride = Attribute{{1, 1}, DataType::int8_t};
auto pad = Attribute{{1, 1}, DataType::int8_t};
auto nanMode = Attribute{{1}, DataType::uint32_t, {1}};

// Create an output Tensor
auto outputTensor = Tensor{DataType::int8_t, std::vector<unsigned int>{1,1}};

// Create the operator
auto maxPool2d = graph.AddMaxPool2dOperator(input, kernel, stride, pad, nanMode, outputTensor);

// Set the graphs output to be the output of the maxPool2d operator added above
graph.AddOutput(maxPool2d, 1);

// Once all IO and operators are set FinalizeGraph() fixes the type of the graph
// After being called the graph becomes immutable
graph.FinalizeGraph();

// Use Module to write the full binary.
std::vector<uint32_t> binary = WriteToBinary(module);
```

Here, the `graph.AddInput` function inserts the given tensor definition into
the graph instance, and returns a `ResId` of where the tensor is in the graph.
This `ResId` can then be used when adding an operator to the graph, setting
the given operator's input to the tensor definition.

This is also useful when chaining multiple operators, as the `ResId` returned
by the `graph.Add...Operator` functions can be used as an input to the next operator.

Along with the aforementioned `graph.AddInput` for dynamic inputs, constant inputs can also be added.
Two types are supported currently, tensor constants and graph constants.

Tensor constants are added using `Attribute` instances and contain data directly,
and typically they're used for constant inputs with 16 or less elements.
They can be initialized as follows:
```c++
Attribute attr{{3, 3}, DataType::uint32_t, {2}};
ResId tensorConstantResId = graph.AddTensorConstant(attr);
```

Graph constants are added using `Tensor` instances, specifying just the shape,
where the constant data is supplied externally.
Typically, they are used for constant inputs with more than 16 elements.
They can be initialized as follows:
``` c++
Tensor tensor{DataType::int8_t, {1,1}}
ResId graphConstantResId = graph.AddGraphConstant(tensor);
```

The `ResId`s returned from `graph.AddTensorConstant` or `graph.AddGraphConstant` can be used when adding
an operator, the same way the `ResId` from `graph.AddInput` would be used, and can be supplied
to any `Add...Operator` function in place of inputs.

More examples with various input and attribute configurations can be found in operator tests
('src/test/operatorTests/*').

## Model information

    /// Model state is primarily represented and stored as SPIRV-V in tfsc::Module::m_SPIRVGraph.
    /// The spirv module can be parsed using the tosa-for-spirv-codegen/include/spirv headers and following TOSA SPIR-V specification
    /// Examples can be found in src/TosaForSpirvCodegen.cpp and tools/vgfwriter/src/VgfWriter.cpp

### Unit Tests

Unit test are built by default for the graph API.

They can be run using the following command:
``` bash
# To run all tests, including graph unit tests
./tosa_for_spirv_tests

# To run specifically graph unit tests
./tosa_for_spirv_tests --gtest_filter=TOSA_FOR_SPIRV_CODEGEN_OPERATOR.*
```

## Doxygen & Sphinx Documentation
### Doxygen
Doxygen is used to generate comprehensive documentation for this project which gives
a better insight into the API's and how to use them. To generate the Doxygen documentation
the following command can be run:

``` bash
doxygen ./docs/Doxyfile
```

The above command will create the documentation in the docs folder, the documentation can then be opened in a browser
as follows:

``` bash
<browser_name> ./docs/html/index.xhtml
```

### Sphinx
Sphinx is another tool used to generate structured project documentation, It integrates with Doxygen allowing automatic inclusion of API references.

To build Sphinx documentation you must enable the build option.
``` bash
cmake -DML_SDK_BUILD_DOCS=ON ..
```

#### Prerequisites
Make sure the following dependencies are installed before generating Sphinx documentation
```bash
apt install sphinx
pip install breathe sphinx_rtd_theme myst_parser
```

### Generating Documentation
Once the dependencies are installed and the build flag is enabled, you can generate the documentation with:
```bash
make
```

The output will be placed in the build directory, you can open the generated documentation in a browser as follows:
```bash
<browser_name> build/docs/sphinx-output/index.html
```
## Code Formatting (clang-format 11)

This project uses **clang-format 11** to enforce consistent code style.

### Formatting Code

To format your code:

```bash
clang-format-11 -i path/to/file.cpp
```

## TosaRegen Usage
You use the TosaRegen library through functions in the header files in the `tools/tosaregen/include` directory.

The `TosaOperator.hpp` file provides a graph-independent TOSA operator representation that does not depend on SPIR-V or the tosa_for_spirv_codegen library.

The `SpirvParser.hpp` file includes functions that convert `tfsc::spirv::Instruction` instances into structures compatible with `TosaOperator.hpp`.

The `TosaRegen.hpp` file provides the basic API. You use it to generate operator definitions or TOSA Serialization Library structures from a `tfsc::spirv::Module`.

Each function includes Doxygen-style comments in the code and documentation. You can find test cases in the `tools/tosaregen/src/test` directory. These test files serve as examples for using the library.

You can use the TosaRegen executable to process SPIR-V disassembly text files. It generates either operator definitions or TOSA Serialization Library flatbuffer files.

You can create SPIR-V disassembly files from VGF files or SPV binaries using tools in the `./external` directory, as described in earlier sections.

To run the tool, use the following command:
```bash
./<build_folder>/tools/tosaregen/tosaregen <path_to_spirv_text_file> <action> [options]
```

The `action` can be `ops`, `tests`, or `tosa`.

- The `ops` action generates operator definitions to standard output.
- The `tests` action creates complete operator tests and writes them to files grouped by operator.
- The `tosa` action generates a TOSA Serialization Library flatbuffer file that contains a TOSA representation of the SPIR-V content.

You can use the `--unique` option with `ops` and `tests` to generate one operator definition or test per unique operator type.

For the `tests` action, you can use the following additional options:
- `--dir <output_test_files_directory>`: Specifies the directory where the tool saves the generated test files.
- `--overwrite`: Enables the tool to overwrite existing test files instead of appending to them.

For the `tosa` action, use the `--output <output_file_name>` option to specify the name of the `.tosa` file to save the output data.

To view more information, run the tool without any arguments or use the `--help` option.

## Dependencies
External dependencies used by tosa-for-spirv-codegen:

| Tool                       | License           | Description                                                  | Version                                  | Provenience |
|----------------------------|-------------------|--------------------------------------------------------------|------------------------------------------|--|
| GoogleTest                 | BSD 3-Clause      | C++ testing framework                                        | v1.13.0                                  | https://github.com/google/googletest |
| SPIR-V Headers             | Khronos Group Inc | Machine-readable files for the SPIR-V Registry               | 01e0577914a75a2569c846778c2f93aa8e6feddd | https://github.com/KhronosGroup/SPIRV-Headers |
| SPIR-V Tools               | Khronos Group Inc | API and commands for processing SPIR-V modules               | 7f2d9ee926f98fc77a3ed1e1e0f113b8c9c49458 | https://github.com/KhronosGroup/SPIRV-Tools |
| TOSA Serialization Library | Apache-2.0        | Provides methods to read and write serialized TOSA graphs    | v0.60.0                                  | https://review.mlplatform.org/plugins/gitiles/tosa/serialization_lib/ |
| JSON for Modern C++        | MIT               | Provides methods to read and write JSON                      | 3.11.2                                   | https://github.com/nlohmann/json/ |
| argparse                   | MIT               | Provides methods to parse command-line arguments             | v3.0                                     | https://github.com/p-ranav/argparse |
| ml-sdk-vgf-lib             | Apache-2.0        | Provides methods to encode SPIR-V TOSA graph into vgf format | 55d73eaa8c88f74cf5732a3a8902450f208006af | https://github.com/arm/ai-ml-sdk-vgf-library |
| cmake                      | BSD 3-Clause      | C++ build tool                                               | v3.25.0                                  | https://github.com/Kitware/CMake |

## Build Flags
tosa_for_spirv_codegen uses the following security related build flags in their code:

| Build flags	       |
|---------------------|
| -Wall	           |
| -Wextra             |
| -Wold-style-cast    |
| -Wno-missing-braces |
| -Wconversion        |
| -Wsign-conversion   |
| -Werror             |

## License

The *tosa_for_spirv_codegen* project is licensed under Apache-2.0.

Copyright (c) 2023-2025 Arm Limited.

## Attributions

SPIR-V is a trademark of the Khronos Group Inc.
Android is a trademark of Google Inc.
CMake is a trademark of Kitware Inc.

